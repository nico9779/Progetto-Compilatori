%option noyywrap
%{

//Use it to enable debugging output, comment the line to disable it.
//#define PROJECT_LOGGING


#include <stdlib.h>
#include <string.h>

#include "ut_compiler_marco.tab.h"


//Logging function.
void LOG_FL(const char* str)
{
	#ifdef PROJECT_LOGGING
		printf("%s", str);
	#endif
}


extern YYSTYPE yylval;

%}

delim                  		[ \t\r\n]
ws                      	{delim}+
letter                  	[A-Za-z]
digit                   	[0-9]

id							{letter}({letter}|{digit})*
number						{digit}+

%%

	/* ******************** WHITESPACES ******************** */

{ws}                    	{}		/* eat up whitespaces */

	/* ******************** PUNCTUATORS ******************** */

","							{ LOG_FL("F<pt_comma>\n");     return pt_comma; }
";"							{ LOG_FL("F<pt_semicolon>\n"); return pt_semicolon; }

	/* ******************** KEYWORDS ******************** */

"do"						{ LOG_FL("F<kw_do>\n");    return kw_do; }
"else"						{ LOG_FL("F<kw_else>\n");  return kw_else; }
"false"						{ LOG_FL("F<kw_false>\n"); return kw_false; }
"for"						{ LOG_FL("F<kw_for>\n");   return kw_for; }
"if"						{ LOG_FL("F<kw_if>\n");    return kw_if; }
"int"						{ LOG_FL("F<kw_int>\n");   return kw_int; }
"print"						{ LOG_FL("F<kw_print>\n"); return kw_print; }
"true"						{ LOG_FL("F<kw_true>\n");  return kw_true; }
"while"						{ LOG_FL("F<kw_while>\n"); return kw_while; }

	/* ******************** BRACKETS ******************** */

"("							{ LOG_FL("F<br_round_open>\n");  return br_round_open; }
")"							{ LOG_FL("F<br_round_close>\n"); return br_round_close; }
"{"							{ LOG_FL("F<br_curly_open>\n");  return br_curly_open; }
"}"							{ LOG_FL("F<br_curly_close>\n"); return br_curly_close; }

	/* ******************** ARITHMETIC OPERATORS ******************** */

"*"							{ LOG_FL("F<op_mul>\n"); return op_mul; }
"/"							{ LOG_FL("F<op_div>\n"); return op_div; }
"%"							{ LOG_FL("F<op_mod>\n"); return op_mod; }
"+"							{ LOG_FL("F<op_add>\n"); return op_add; }
"-"							{ LOG_FL("F<op_sub>\n"); return op_sub; }

	/* ******************** ASSIGNMENT OPERATORS ******************** */

"="							{ LOG_FL("F<op_assign>\n");     return op_assign; }

"*="						{ LOG_FL("F<op_mul_assign>\n"); return op_mul_assign; }
"/="						{ LOG_FL("F<op_div_assign>\n"); return op_div_assign; }
"%="						{ LOG_FL("F<op_mod_assign>\n"); return op_mod_assign; }
"+="						{ LOG_FL("F<op_add_assign>\n"); return op_add_assign; }
"-="						{ LOG_FL("F<op_sub_assign>\n"); return op_sub_assign; }

	/* ******************** RELATIONAL OPERATORS ******************** */

"=="						{ LOG_FL("F<op_eq>\n"); return op_eq; }
"!="						{ LOG_FL("F<op_ne>\n"); return op_ne; }
"<"							{ LOG_FL("F<op_lt>\n"); return op_lt; }
"<="						{ LOG_FL("F<op_le>\n"); return op_le; }
">"							{ LOG_FL("F<op_gt>\n"); return op_gt; }
">="						{ LOG_FL("F<op_ge>\n"); return op_ge; }

	/* ******************** LOGICAL OPERATORS ******************** */

"and"						{ LOG_FL("F<op_and>\n"); return op_and; }
"or"						{ LOG_FL("F<op_or>\n");  return op_or; }
"xor"						{ LOG_FL("F<op_xor>\n"); return op_xor; }
"not"						{ LOG_FL("F<op_not>\n"); return op_not; }

	/* ******************** OTHERS ******************** */

{id}						{
								LOG_FL("F<id>\n");

								yylval.address.addr = strdup(yytext);							
								return id;
							}

{number}         			{
								LOG_FL("F<int_number>\n");

								yylval.address.addr = strdup(yytext);
								return int_number;
							}

["][^\"]*["]|['][^\']*[']	{
								LOG_FL("F<string>\n");

								/* Allocate heap memory to store the string, and put the pointer in yylval. */
								yylval.address.addr = (char*) malloc(yyleng - 1);
								memcpy(yylval.address.addr, yytext + 1, yyleng - 2);
								yylval.address.addr[yyleng - 2] = 0;

								return string;
							}


%%