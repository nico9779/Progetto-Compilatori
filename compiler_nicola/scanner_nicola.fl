%option noyywrap

%{
#include <stdio.h>
#include "compiler_nicola.tab.h"
%}

delim                   [ \t\n]
ws                      {delim}+
letter                  [A-Za-z]
digit                   [0-9]

id                      {letter}({letter}|{digit})*
number                  {digit}+

%%

{ws}                    {}     /* eat up whitespaces */

if                      { printf("<keyword, IF>\n"); }
else                    { printf("<keyword, ELSE>\n"); }
do                      { printf("<keyword, DO>\n"); }
while                   { printf("<keyword, WHILE>\n"); }
for                     { printf("<keyword, FOR>\n"); }
int                     { printf("<keyword, INT>\n"); }
return                  { printf("<keyword, RETURN>\n"); }

"true"|"TRUE"			{ printf("<keyword, TRUE>\n"); return KW_TRUE; }
"false"|"FALSE"			{ printf("<keyword, FALSE>\n"); return KW_FALSE; }

"//"[^\n]*              {}   /* eat up one-line comments */
"/*"[^"*/"]*"*/"        {}   /* eat up multi-line comments */

["][^\"]*["]            { printf("<string, %s>\n", yytext); }     /* strings delimited by ""  */
['][^\']*[']            { printf("<string, %s>\n", yytext); }     /* strings delimited by ''  */

"<"                     { printf("<operator, LT>\n"); return OP_LT; }
"<="                    { printf("<operator, LE>\n"); return OP_LE; }
"=="                    { printf("<operator, EQ>\n"); return OP_EQ; }
"!="                    { printf("<operator, NEQ>\n"); return OP_NEQ; }
">"                     { printf("<operator, GT>\n"); return OP_GT; }
">="                    { printf("<operator, GE>\n"); return OP_GE; }

"+"	                    { printf("<operator, ADDITION>\n"); return OP_ADD;}
"-"	                    { printf("<operator, SUBTRACTION>\n"); return OP_SUB;}
"*"	                    { printf("<operator, MULTIPLICATION>\n"); return OP_MUL;}
"/"	                    { printf("<operator, DIVISION>\n"); return OP_DIV;}
"%"                     { printf("<operator, MODULO>\n"); }

"="                     { printf("<operator, ASSIGNMENT>\n"); }

"and"|"AND"             { printf("<operator, AND>\n"); return OP_AND; }
"or"|"OR"               { printf("<operator, OR>\n"); return OP_OR; }
"not"|"NOT"             { printf("<operator, NOT>\n"); return OP_NOT; }
"xor"|"XOR"				{ printf("<operator, XOR>\n"); return OP_XOR; }

"&"					    { printf("<operator, BITWISE AND>\n"); }
"|"					    { printf("<operator, BITWISE OR>\n"); }
"^"					    { printf("<operator, BITWISE XOR>\n"); }
"~"                     { printf("<operator, UNARY COMPLEMENT>\n"); }
"<<"                    { printf("<operator, SHIFT LEFT>\n"); }
">>"                    { printf("<operator, SHIFT RIGHT>\n"); }

"("	                    { printf("<bracket, OPEN ROUND BRACKET>\n"); return BR_ROUND_OPEN;}
")"	                    { printf("<bracket, CLOSE ROUND BRACKET>\n"); return BR_ROUND_CLOSE;}
"{"	                    { printf("<bracket, OPEN CURLY BRACKET>\n"); }
"}"	                    { printf("<bracket, CLOSE CURLY BRACKET>\n"); }

";"	                    { printf("<semicolon, >\n"); return SEMICOLON;}
","                     { printf("<comma, >\n"); }
":"                     { printf("<colon, >\n"); }

{id}                    { printf("<id, %s>\n", yytext); }
{number}                {
							sscanf(yytext, "%d", &yylval.address.value); 
							printf("<number, %s>\n", yytext); 
						    return NUMBER;
						}
.                       { printf("<unrecognized, %s>\n", yytext); return yytext[0];}

%%
